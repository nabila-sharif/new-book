<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-module-2/chapter-3-content" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Chapter 3: Sensor Simulation &amp; Fidelity | Physical AI &amp; Humanoid Robotics</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ai-book-ashen-chi.vercel.app/img/docusaurus-social-card.svg"><meta data-rh="true" name="twitter:image" content="https://ai-book-ashen-chi.vercel.app/img/docusaurus-social-card.svg"><meta data-rh="true" property="og:url" content="https://ai-book-ashen-chi.vercel.app/docs/module-2/chapter-3-content"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Chapter 3: Sensor Simulation &amp; Fidelity | Physical AI &amp; Humanoid Robotics"><meta data-rh="true" name="description" content="Introduction to Sensor Simulation in Digital Twins"><meta data-rh="true" property="og:description" content="Introduction to Sensor Simulation in Digital Twins"><link data-rh="true" rel="icon" href="/img/favicon.svg"><link data-rh="true" rel="canonical" href="https://ai-book-ashen-chi.vercel.app/docs/module-2/chapter-3-content"><link data-rh="true" rel="alternate" href="https://ai-book-ashen-chi.vercel.app/docs/module-2/chapter-3-content" hreflang="en"><link data-rh="true" rel="alternate" href="https://ai-book-ashen-chi.vercel.app/docs/module-2/chapter-3-content" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Chapter 3: Sensor Simulation & Fidelity","item":"https://ai-book-ashen-chi.vercel.app/docs/module-2/chapter-3-content"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Physical AI &amp; Humanoid Robotics RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Physical AI &amp; Humanoid Robotics Atom Feed"><link rel="stylesheet" href="/assets/css/styles.ccbbb54d.css">
<script src="/assets/js/runtime~main.195844ec.js" defer="defer"></script>
<script src="/assets/js/main.5f5036ab.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Physical AI &amp; Humanoid Robotics</b></a><a class="navbar__item navbar__link" href="/docs/physical-ai-humanoid-robotics/">Tutorial</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/module-2">Module 2</a><a class="navbar__item navbar__link" href="/docs/module-3">Module 3</a><a class="navbar__item navbar__link" href="/docs/module-4/">Module 4</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/module-2"><span title="Module 2: Digital Twin (Gazebo &amp; Unity)" class="linkLabel_WmDU">Module 2: Digital Twin (Gazebo &amp; Unity)</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docs/module-2/chapter-1-content"><span title="Module 2: Digital Twin (Gazebo &amp; Unity)" class="categoryLinkLabel_W154">Module 2: Digital Twin (Gazebo &amp; Unity)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/module-2/chapter-1-content"><span title="Chapter 1: Physics Simulation with Gazebo" class="linkLabel_WmDU">Chapter 1: Physics Simulation with Gazebo</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/module-2/chapter-2-content"><span title="Chapter 2: High-Fidelity Environments with Unity" class="linkLabel_WmDU">Chapter 2: High-Fidelity Environments with Unity</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/module-2/chapter-3-content"><span title="Chapter 3: Sensor Simulation &amp; Fidelity" class="linkLabel_WmDU">Chapter 3: Sensor Simulation &amp; Fidelity</span></a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Module 2: Digital Twin (Gazebo &amp; Unity)</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Chapter 3: Sensor Simulation &amp; Fidelity</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Chapter 3: Sensor Simulation &amp; Fidelity</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction-to-sensor-simulation-in-digital-twins">Introduction to Sensor Simulation in Digital Twins<a href="#introduction-to-sensor-simulation-in-digital-twins" class="hash-link" aria-label="Direct link to Introduction to Sensor Simulation in Digital Twins" title="Direct link to Introduction to Sensor Simulation in Digital Twins" translate="no">​</a></h2>
<p>Sensor simulation is a critical component of digital twin systems for robotics, as it provides the virtual robot with environmental perception capabilities that mirror those of its physical counterpart. Accurate sensor simulation enables:</p>
<ul>
<li class="">Development and testing of perception algorithms in a safe environment</li>
<li class="">Training of machine learning models with synthetic data</li>
<li class="">Validation of navigation and control systems</li>
<li class="">Evaluation of robot performance under various environmental conditions</li>
</ul>
<p>The fidelity of sensor simulation directly impacts the transferability of algorithms from simulation to reality, making it essential to model sensor characteristics, noise, and limitations accurately.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-simulation-and-noise-characteristics">LiDAR Simulation and Noise Characteristics<a href="#lidar-simulation-and-noise-characteristics" class="hash-link" aria-label="Direct link to LiDAR Simulation and Noise Characteristics" title="Direct link to LiDAR Simulation and Noise Characteristics" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-physics-in-simulation">LiDAR Physics in Simulation<a href="#lidar-physics-in-simulation" class="hash-link" aria-label="Direct link to LiDAR Physics in Simulation" title="Direct link to LiDAR Physics in Simulation" translate="no">​</a></h3>
<p>LiDAR (Light Detection and Ranging) sensors in simulation are typically implemented using raycasting techniques that mimic the behavior of real laser beams. The simulation must account for:</p>
<ul>
<li class=""><strong>Ray casting</strong>: Virtual laser beams projected from the sensor origin</li>
<li class=""><strong>Distance measurement</strong>: Calculation of distances to nearest obstacles</li>
<li class=""><strong>Angular resolution</strong>: Horizontal and vertical beam spacing</li>
<li class=""><strong>Range limitations</strong>: Maximum and minimum detection distances</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-simulation-implementation">LiDAR Simulation Implementation<a href="#lidar-simulation-implementation" class="hash-link" aria-label="Direct link to LiDAR Simulation Implementation" title="Direct link to LiDAR Simulation Implementation" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections.Generic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class LIDARSimulator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;LIDAR Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int horizontalRays = 360;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int verticalRays = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float minAngle = -30f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxAngle = 15f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxRange = 20.0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float minRange = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LayerMask detectionMask = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Noise Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float distanceNoiseStdDev = 0.02f;  // 2cm standard deviation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float angularNoiseStdDev = 0.001f;  // Small angular error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;float&gt; scanData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float[] verticalAngles;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeLIDAR();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void InitializeLIDAR()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData = new List&lt;float&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CalculateVerticalAngles();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void CalculateVerticalAngles()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        verticalAngles = new float[verticalRays];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float angleStep = (maxAngle - minAngle) / (verticalRays - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; verticalRays; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            verticalAngles[i] = minAngle + (i * angleStep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float[] GetLIDARScan()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.Clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int h = 0; h &lt; horizontalRays; h++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float horizontalAngle = (360.0f / horizontalRays) * h * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int v = 0; v &lt; verticalRays; v++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float verticalAngle = verticalAngles[v] * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Calculate ray direction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Vector3 rayDirection = CalculateRayDirection(horizontalAngle, verticalAngle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Perform raycast</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RaycastHit hit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (Physics.Raycast(transform.position, rayDirection, out hit, maxRange, detectionMask))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float distance = hit.distance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Add noise to the measurement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    distance = AddDistanceNoise(distance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    scanData.Add(distance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // No obstacle detected within range</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    scanData.Add(maxRange + 1.0f); // Indicate no return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return scanData.ToArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 CalculateRayDirection(float horizontalAngle, float verticalAngle)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate the ray direction based on horizontal and vertical angles</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 direction = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Mathf.Cos(verticalAngle) * Mathf.Cos(horizontalAngle),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Mathf.Cos(verticalAngle) * Mathf.Sin(horizontalAngle),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Mathf.Sin(verticalAngle)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Transform to world space based on sensor orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return transform.TransformDirection(direction);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float AddDistanceNoise(float distance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add Gaussian noise to distance measurement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float noise = RandomGaussian() * distanceNoiseStdDev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float noisyDistance = distance + noise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Ensure distance is within valid range</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mathf.Clamp(noisyDistance, minRange, maxRange + 1.0f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float RandomGaussian()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Box-Muller transform for Gaussian random number generation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u1 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u2 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (u1 &lt; Mathf.Epsilon) u1 = Mathf.Epsilon;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float gaussian = Mathf.Sqrt(-2.0f * Mathf.Log(u1)) * Mathf.Cos(2.0f * Mathf.PI * u2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return gaussian;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="noise-modeling-for-lidar-sensors">Noise Modeling for LiDAR Sensors<a href="#noise-modeling-for-lidar-sensors" class="hash-link" aria-label="Direct link to Noise Modeling for LiDAR Sensors" title="Direct link to Noise Modeling for LiDAR Sensors" translate="no">​</a></h3>
<p>Real LiDAR sensors exhibit various types of noise and systematic errors:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="statistical-noise-models">Statistical Noise Models<a href="#statistical-noise-models" class="hash-link" aria-label="Direct link to Statistical Noise Models" title="Direct link to Statistical Noise Models" translate="no">​</a></h4>
<ul>
<li class=""><strong>Gaussian noise</strong>: Random measurement errors following a normal distribution</li>
<li class=""><strong>Intensity-based noise</strong>: Distance measurement errors that vary with return intensity</li>
<li class=""><strong>Multi-path interference</strong>: Errors due to multiple reflections</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="systematic-errors">Systematic Errors<a href="#systematic-errors" class="hash-link" aria-label="Direct link to Systematic Errors" title="Direct link to Systematic Errors" translate="no">​</a></h4>
<ul>
<li class=""><strong>Zero-point calibration errors</strong>: Constant offset in measurements</li>
<li class=""><strong>Scale factor errors</strong>: Proportional errors across the measurement range</li>
<li class=""><strong>Angular misalignment</strong>: Errors in beam pointing direction</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="advanced-lidar-simulation-features">Advanced LiDAR Simulation Features<a href="#advanced-lidar-simulation-features" class="hash-link" aria-label="Direct link to Advanced LiDAR Simulation Features" title="Direct link to Advanced LiDAR Simulation Features" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AdvancedLIDARSimulator : LIDARSimulator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Advanced Noise Models&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AnimationCurve distanceNoiseCurve;  // Distance-dependent noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float temperatureCoefficient = 0.001f;  // Temperature effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float vibrationNoise = 0.01f;  // Vibration-induced errors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Environmental Effects&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float atmosphericAttenuation = 0.001f;  // Fog/rain effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float dustAttenuation = 0.002f;  // Dust/particle effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float AddAdvancedDistanceNoise(float distance, float temperature, float vibration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Base noise from distance curve</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float distanceBasedNoise = distanceNoiseCurve.Evaluate(distance) * distanceNoiseStdDev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Temperature effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float temperatureEffect = temperature * temperatureCoefficient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Vibration effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float vibrationEffect = vibration * vibrationNoise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Combine all noise sources</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float totalNoise = Mathf.Sqrt(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Mathf.Pow(distanceBasedNoise, 2) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Mathf.Pow(temperatureEffect, 2) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Mathf.Pow(vibrationEffect, 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return distance + RandomGaussian() * totalNoise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float ApplyEnvironmentalEffects(float distance, float atmosphericDensity, float particleDensity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Apply atmospheric attenuation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float atmosphericFactor = Mathf.Exp(-atmosphericAttenuation * distance * atmosphericDensity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Apply dust/particle attenuation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float dustFactor = Mathf.Exp(-dustAttenuation * distance * particleDensity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return distance / (atmosphericFactor * dustFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="depth-camera-and-rgb-d-simulation">Depth Camera and RGB-D Simulation<a href="#depth-camera-and-rgb-d-simulation" class="hash-link" aria-label="Direct link to Depth Camera and RGB-D Simulation" title="Direct link to Depth Camera and RGB-D Simulation" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="depth-camera-fundamentals">Depth Camera Fundamentals<a href="#depth-camera-fundamentals" class="hash-link" aria-label="Direct link to Depth Camera Fundamentals" title="Direct link to Depth Camera Fundamentals" translate="no">​</a></h3>
<p>Depth cameras in simulation must accurately model:</p>
<ul>
<li class=""><strong>Pinhole camera model</strong>: Geometric projection of 3D points to 2D image</li>
<li class=""><strong>Depth measurement</strong>: Distance from camera to scene points</li>
<li class=""><strong>Noise characteristics</strong>: Sensor-specific noise patterns</li>
<li class=""><strong>Resolution limitations</strong>: Finite pixel resolution and quantization</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="depth-camera-implementation">Depth Camera Implementation<a href="#depth-camera-implementation" class="hash-link" aria-label="Direct link to Depth Camera Implementation" title="Direct link to Depth Camera Implementation" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DepthCameraSimulator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Camera Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float fov = 60f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float nearClip = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float farClip = 10.0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Noise Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float depthNoiseStdDev = 0.01f;  // 1cm standard deviation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float radialDistortion = 0.1f;   // Lens distortion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float tangentialDistortion = 0.01f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Camera depthCamera;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private RenderTexture depthTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float[,] depthData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SetupDepthCamera();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CreateDepthTexture();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthData = new float[width, height];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SetupDepthCamera()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera = GetComponent&lt;Camera&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (depthCamera == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            depthCamera = gameObject.AddComponent&lt;Camera&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.fieldOfView = fov;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.nearClipPlane = nearClip;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.farClipPlane = farClip;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.depth = -1; // Render after other cameras</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.enabled = false; // Don&#x27;t render automatically</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void CreateDepthTexture()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTexture = new RenderTexture(width, height, 24, RenderTextureFormat.Depth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTexture.Create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.targetTexture = depthTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float[,] GetDepthImage()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Render the scene from depth camera</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.Render();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Read depth data from texture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = depthTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Texture2D depthTex = new Texture2D(width, height, TextureFormat.RGB24, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTex.ReadPixels(new Rect(0, 0, width, height), 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTex.Apply();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert texture to depth values</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Color[] pixels = depthTex.GetPixels();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int pixelIndex = y * width + x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Color pixel = pixels[pixelIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Convert color to depth value (simplified)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float rawDepth = pixel.r; // Assuming red channel contains depth info</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float depth = ConvertRawDepthToMeters(rawDepth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Add noise to depth measurement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                depth = AddDepthNoise(depth, x, y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                depthData[x, y] = depth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Clean up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DestroyImmediate(depthTex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return depthData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float ConvertRawDepthToMeters(float rawDepth)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert normalized depth value to meters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This depends on your specific depth rendering setup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float depth = nearClip + rawDepth * (farClip - nearClip);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return depth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float AddDepthNoise(float depth, int x, int y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add position-dependent noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float noise = RandomGaussian() * depthNoiseStdDev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add quantization noise based on pixel position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float quantization = (x % 4) * 0.001f + (y % 4) * 0.001f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return depth + noise + quantization;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float RandomGaussian()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Box-Muller transform</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u1 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u2 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (u1 &lt; Mathf.Epsilon) u1 = Mathf.Epsilon;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mathf.Sqrt(-2.0f * Mathf.Log(u1)) * Mathf.Cos(2.0f * Mathf.PI * u2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void OnDestroy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (depthTexture != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            depthTexture.Release();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="rgb-d-sensor-pipeline">RGB-D Sensor Pipeline<a href="#rgb-d-sensor-pipeline" class="hash-link" aria-label="Direct link to RGB-D Sensor Pipeline" title="Direct link to RGB-D Sensor Pipeline" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class RGBDSensorPipeline : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;RGB-D Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DepthCameraSimulator depthCamera;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Camera rgbCamera;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Calibration Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector2 principalPoint = new Vector2(320, 240);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector2 focalLength = new Vector2(525, 525);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float baseline = 0.075f; // For stereo cameras</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float[,] depthData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Color32[] rgbData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3[,] pointCloud;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeRGBDPipeline();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void InitializeRGBDPipeline()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Initialize depth camera</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (depthCamera == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            depthCamera = GetComponent&lt;DepthCameraSimulator&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Initialize RGB camera</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rgbCamera == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rgbCamera = GetComponent&lt;Camera&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pointCloud = new Vector3[width, height];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void UpdateSensorData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get depth and RGB data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthData = depthCamera.GetDepthImage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rgbData = GetRGBData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Generate point cloud from depth data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GeneratePointCloud();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Color32[] GetRGBData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Capture RGB image from camera</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture currentRT = RenderTexture.active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = rgbCamera.targetTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Texture2D tex = new Texture2D(width, height, TextureFormat.RGB24, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tex.ReadPixels(new Rect(0, 0, width, height), 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tex.Apply();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Color32[] pixels = tex.GetPixels32();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = currentRT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DestroyImmediate(tex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pixels;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void GeneratePointCloud()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float depth = depthData[x, y];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (depth &gt; 0 &amp;&amp; depth &lt; depthCamera.farClip)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Convert pixel coordinates to 3D world coordinates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float worldX = (x - principalPoint.x) * depth / focalLength.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float worldY = (y - principalPoint.y) * depth / focalLength.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float worldZ = depth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Transform from camera to world coordinates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Vector3 localPoint = new Vector3(worldX, worldY, worldZ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Vector3 worldPoint = transform.TransformPoint(localPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pointCloud[x, y] = worldPoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pointCloud[x, y] = Vector3.zero; // Invalid point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3[,] GetPointCloud()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pointCloud;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-modeling-and-drift">IMU Modeling and Drift<a href="#imu-modeling-and-drift" class="hash-link" aria-label="Direct link to IMU Modeling and Drift" title="Direct link to IMU Modeling and Drift" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-fundamentals-in-simulation">IMU Fundamentals in Simulation<a href="#imu-fundamentals-in-simulation" class="hash-link" aria-label="Direct link to IMU Fundamentals in Simulation" title="Direct link to IMU Fundamentals in Simulation" translate="no">​</a></h3>
<p>An Inertial Measurement Unit (IMU) typically contains:</p>
<ul>
<li class=""><strong>Accelerometer</strong>: Measures linear acceleration</li>
<li class=""><strong>Gyroscope</strong>: Measures angular velocity</li>
<li class=""><strong>Magnetometer</strong>: Measures magnetic field (for heading)</li>
</ul>
<p>IMU simulation must model various error sources:</p>
<ul>
<li class=""><strong>Bias</strong>: Constant offset in measurements</li>
<li class=""><strong>Scale factor errors</strong>: Proportional errors</li>
<li class=""><strong>Noise</strong>: Random measurement variations</li>
<li class=""><strong>Drift</strong>: Time-dependent bias changes</li>
<li class=""><strong>Temperature effects</strong>: Performance variation with temperature</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-simulation-implementation">IMU Simulation Implementation<a href="#imu-simulation-implementation" class="hash-link" aria-label="Direct link to IMU Simulation Implementation" title="Direct link to IMU Simulation Implementation" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class IMUSimulator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;IMU Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerNoiseDensity = 0.002f;   // m/s^2/sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeNoiseDensity = 0.0001f;      // rad/s/sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerRandomWalk = 0.001f;     // m/s^3/sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeRandomWalk = 0.00001f;       // rad/s^2/sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float magnetometerNoise = 0.1f;             // uT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Bias Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerBiasStability = 0.01f;   // m/s^2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeBiasStability = 0.001f;      // rad/s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float biasCorrelationTime = 3600.0f;        // seconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Temperature Effects&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float temperatureCoefficientAccel = 0.0001f; // (m/s^2)/degC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float temperatureCoefficientGyro = 0.00001f; // (rad/s)/degC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float ambientTemperature = 25.0f;           // degC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 trueAcceleration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 trueAngularVelocity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 trueMagneticField;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 accelerometerBias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 gyroscopeBias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 accelerometerWalk;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 gyroscopeWalk;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float lastUpdateTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeIMU();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void InitializeIMU()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Initialize biases with random values within stability limits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accelerometerBias = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UnityEngine.Random.Range(-accelerometerBiasStability, accelerometerBiasStability),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UnityEngine.Random.Range(-accelerometerBiasStability, accelerometerBiasStability),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UnityEngine.Random.Range(-accelerometerBiasStability, accelerometerBiasStability)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gyroscopeBias = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UnityEngine.Random.Range(-gyroscopeBiasStability, gyroscopeBiasStability),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UnityEngine.Random.Range(-gyroscopeBiasStability, gyroscopeBiasStability),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UnityEngine.Random.Range(-gyroscopeBiasStability, gyroscopeBiasStability)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accelerometerWalk = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gyroscopeWalk = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastUpdateTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UpdateIMUBias();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void UpdateIMUBias()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float deltaTime = Time.time - lastUpdateTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastUpdateTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Update random walk components (first-order Gauss-Markov process)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float decayFactor = Mathf.Exp(-deltaTime / biasCorrelationTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accelerometerWalk += GetWhiteNoiseVector(accelerometerRandomWalk) * Mathf.Sqrt(deltaTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gyroscopeWalk += GetWhiteNoiseVector(gyroscopeRandomWalk) * Mathf.Sqrt(deltaTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Apply decay to bias (bias instability over time)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accelerometerBias *= decayFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gyroscopeBias *= decayFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add new random walk components</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accelerometerBias += accelerometerWalk * deltaTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gyroscopeBias += gyroscopeWalk * deltaTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public sensor_msgs.Imu GetIMUData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get true values from the simulation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trueAcceleration = GetTrueAcceleration();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trueAngularVelocity = GetTrueAngularVelocity();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trueMagneticField = GetTrueMagneticField();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Apply sensor model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 measuredAccel = ApplyAccelerometerModel(trueAcceleration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 measuredGyro = ApplyGyroscopeModel(trueAngularVelocity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 measuredMag = ApplyMagnetometerModel(trueMagneticField);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create ROS IMU message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sensor_msgs.Imu imuMsg = new sensor_msgs.Imu();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Fill acceleration data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.linear_acceleration = new geometry_msgs.Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            measuredAccel.x, measuredAccel.y, measuredAccel.z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Fill angular velocity data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.angular_velocity = new geometry_msgs.Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            measuredGyro.x, measuredGyro.y, measuredGyro.z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Estimate orientation from gravity and magnetic field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.orientation = EstimateOrientation(measuredAccel, measuredMag);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set header information</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.header.stamp = GetROSTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.header.frame_id = &quot;imu_link&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return imuMsg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 ApplyAccelerometerModel(Vector3 trueAccel)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add temperature effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float temperatureEffect = (ambientTemperature - 25.0f) * temperatureCoefficientAccel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 tempEffectedAccel = trueAccel + Vector3.one * temperatureEffect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add bias</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 biasedAccel = tempEffectedAccel + accelerometerBias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noise = GetWhiteNoiseVector(accelerometerNoiseDensity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noisyAccel = biasedAccel + noise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return noisyAccel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 ApplyGyroscopeModel(Vector3 trueGyro)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add temperature effect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float temperatureEffect = (ambientTemperature - 25.0f) * temperatureCoefficientGyro;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 tempEffectedGyro = trueGyro + Vector3.one * temperatureEffect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add bias</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 biasedGyro = tempEffectedGyro + gyroscopeBias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noise = GetWhiteNoiseVector(gyroscopeNoiseDensity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noisyGyro = biasedGyro + noise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return noisyGyro;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 ApplyMagnetometerModel(Vector3 trueMag)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add noise to magnetic field measurement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noise = GetWhiteNoiseVector(magnetometerNoise);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return trueMag + noise;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetTrueAcceleration()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get true acceleration from physics simulation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rb != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // True acceleration is the derivative of velocity plus gravity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 gravity = Physics.gravity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return rb.velocity / Time.fixedDeltaTime + gravity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Fallback: assume zero acceleration if no rigidbody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetTrueAngularVelocity()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get true angular velocity from physics simulation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rb != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return rb.angularVelocity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Fallback: assume zero angular velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetTrueMagneticField()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Return Earth&#x27;s magnetic field (simplified)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In real implementation, this would account for local magnetic anomalies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Vector3(0.22f, 0.0f, 0.45f); // ~45 degree inclination, 0.5 uT magnitude</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetWhiteNoiseVector(float noiseDensity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * noiseDensity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * noiseDensity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * noiseDensity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    geometry_msgs.Quaternion EstimateOrientation(Vector3 accel, Vector3 mag)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Simple orientation estimation from accelerometer and magnetometer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This is a simplified version - real implementation would use more sophisticated filtering</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Normalize vectors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 normalizedAccel = accel.normalized;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 normalizedMag = mag.normalized;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create coordinate system</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 zAxis = -normalizedAccel; // Accelerometer points opposite to gravity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 xAxis = Vector3.Cross(normalizedMag, zAxis).normalized;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 yAxis = Vector3.Cross(zAxis, xAxis);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create rotation matrix and convert to quaternion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Matrix4x4 rotationMatrix = new Matrix4x4();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationMatrix.SetColumn(0, new Vector4(xAxis.x, yAxis.x, zAxis.x, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationMatrix.SetColumn(1, new Vector4(xAxis.y, yAxis.y, zAxis.y, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationMatrix.SetColumn(2, new Vector4(xAxis.z, yAxis.z, zAxis.z, 0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationMatrix.SetColumn(3, new Vector4(0, 0, 0, 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Quaternion orientation = Quaternion.LookRotation(zAxis, yAxis);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new geometry_msgs.Quaternion(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            orientation.x, orientation.y, orientation.z, orientation.w</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    builtin_interfaces.Time GetROSTime()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Return current ROS time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        double rosTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        builtin_interfaces.Time time = new builtin_interfaces.Time();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        time.sec = (int)rosTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        time.nanosec = (uint)((rosTime - time.sec) * 1e9);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float RandomGaussian()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u1 = UnityEngine.Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u2 = UnityEngine.Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (u1 &lt; Mathf.Epsilon) u1 = Mathf.Epsilon;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mathf.Sqrt(-2.0f * Mathf.Log(u1)) * Mathf.Cos(2.0f * Mathf.PI * u2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="sensor-synchronization-and-data-accuracy">Sensor Synchronization and Data Accuracy<a href="#sensor-synchronization-and-data-accuracy" class="hash-link" aria-label="Direct link to Sensor Synchronization and Data Accuracy" title="Direct link to Sensor Synchronization and Data Accuracy" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="time-synchronization-challenges">Time Synchronization Challenges<a href="#time-synchronization-challenges" class="hash-link" aria-label="Direct link to Time Synchronization Challenges" title="Direct link to Time Synchronization Challenges" translate="no">​</a></h3>
<p>In multi-sensor systems, synchronization is critical for accurate perception. Key challenges include:</p>
<ul>
<li class=""><strong>Clock drift</strong>: Different sensors may have slightly different time bases</li>
<li class=""><strong>Latency variations</strong>: Processing delays can vary between sensors</li>
<li class=""><strong>Update rates</strong>: Different sensors may operate at different frequencies</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="synchronization-implementation">Synchronization Implementation<a href="#synchronization-implementation" class="hash-link" aria-label="Direct link to Synchronization Implementation" title="Direct link to Synchronization Implementation" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections.Generic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SensorSynchronizer : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Synchronization Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxTimeDifference = 0.01f; // 10ms tolerance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxBufferSize = 100;         // Maximum messages to buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Dictionary&lt;string, Queue&lt;SensorMessage&gt;&gt; sensorBuffers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;SynchronizedData&gt; synchronizedData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float lastSynchronizationTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [System.Serializable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class SensorMessage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public string sensorType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public double timestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public object data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [System.Serializable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class SynchronizedData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public double timestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Dictionary&lt;string, object&gt; sensorData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InitializeSynchronization();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void InitializeSynchronization()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sensorBuffers = new Dictionary&lt;string, Queue&lt;SensorMessage&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronizedData = new List&lt;SynchronizedData&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastSynchronizationTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void AddSensorData(string sensorType, double timestamp, object data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!sensorBuffers.ContainsKey(sensorType))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sensorBuffers[sensorType] = new Queue&lt;SensorMessage&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SensorMessage message = new SensorMessage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sensorType = sensorType,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            timestamp = timestamp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            data = data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sensorBuffers[sensorType].Enqueue(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Limit buffer size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (sensorBuffers[sensorType].Count &gt; maxBufferSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sensorBuffers[sensorType].Dequeue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Attempt synchronization</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AttemptSynchronization();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void AttemptSynchronization()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Check if we have data from all sensors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (AllSensorsHaveData())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Find the closest timestamps across all sensors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            double referenceTime = FindReferenceTimestamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Check if timestamps are within tolerance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (AreTimestampsWithinTolerance(referenceTime))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Create synchronized data package</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SynchronizedData syncData = CreateSynchronizedData(referenceTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (syncData != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    synchronizedData.Add(syncData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Remove synchronized messages from buffers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    RemoveSynchronizedMessages(referenceTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool AllSensorsHaveData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Check if all registered sensors have at least one message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (var buffer in sensorBuffers.Values)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (buffer.Count == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return sensorBuffers.Count &gt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double FindReferenceTimestamp()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Find the median timestamp across all sensors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;double&gt; allTimestamps = new List&lt;double&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (var buffer in sensorBuffers.Values)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (buffer.Count &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                allTimestamps.Add(buffer.Peek().timestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        allTimestamps.Sort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (allTimestamps.Count == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int middleIndex = allTimestamps.Count / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return allTimestamps[middleIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool AreTimestampsWithinTolerance(double referenceTime)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (var buffer in sensorBuffers.Values)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (buffer.Count &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                double timeDiff = Mathf.Abs((float)(buffer.Peek().timestamp - referenceTime));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (timeDiff &gt; maxTimeDifference)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SynchronizedData CreateSynchronizedData(double referenceTime)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SynchronizedData syncData = new SynchronizedData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        syncData.timestamp = referenceTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        syncData.sensorData = new Dictionary&lt;string, object&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (var kvp in sensorBuffers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            string sensorType = kvp.Key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Queue&lt;SensorMessage&gt; buffer = kvp.Value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (buffer.Count &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SensorMessage message = buffer.Peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                syncData.sensorData[sensorType] = message.data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return syncData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void RemoveSynchronizedMessages(double referenceTime)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (var kvp in sensorBuffers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Queue&lt;SensorMessage&gt; buffer = kvp.Value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (buffer.Count &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SensorMessage message = buffer.Peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                double timeDiff = Mathf.Abs((float)(message.timestamp - referenceTime));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (timeDiff &lt;= maxTimeDifference)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    buffer.Dequeue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;SynchronizedData&gt; GetSynchronizedData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return synchronizedData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void ClearSynchronizedData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronizedData.Clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="evaluating-sensor-realism-and-limitations">Evaluating Sensor Realism and Limitations<a href="#evaluating-sensor-realism-and-limitations" class="hash-link" aria-label="Direct link to Evaluating Sensor Realism and Limitations" title="Direct link to Evaluating Sensor Realism and Limitations" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="sensor-fidelity-metrics">Sensor Fidelity Metrics<a href="#sensor-fidelity-metrics" class="hash-link" aria-label="Direct link to Sensor Fidelity Metrics" title="Direct link to Sensor Fidelity Metrics" translate="no">​</a></h3>
<p>To evaluate the realism of sensor simulation, consider these metrics:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="accuracy-metrics">Accuracy Metrics<a href="#accuracy-metrics" class="hash-link" aria-label="Direct link to Accuracy Metrics" title="Direct link to Accuracy Metrics" translate="no">​</a></h4>
<ul>
<li class=""><strong>Absolute error</strong>: Difference between simulated and real measurements</li>
<li class=""><strong>Precision</strong>: Consistency of repeated measurements</li>
<li class=""><strong>Bias</strong>: Systematic offset in measurements</li>
<li class=""><strong>Drift</strong>: Time-dependent changes in bias</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="performance-metrics">Performance Metrics<a href="#performance-metrics" class="hash-link" aria-label="Direct link to Performance Metrics" title="Direct link to Performance Metrics" translate="no">​</a></h4>
<ul>
<li class=""><strong>Update rate</strong>: Frequency of sensor data generation</li>
<li class=""><strong>Latency</strong>: Delay between physical event and sensor reading</li>
<li class=""><strong>Throughput</strong>: Data processing capacity</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="validation-against-real-hardware">Validation Against Real Hardware<a href="#validation-against-real-hardware" class="hash-link" aria-label="Direct link to Validation Against Real Hardware" title="Direct link to Validation Against Real Hardware" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SensorValidator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Validation Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TextAsset realSensorData;  // CSV file with real sensor data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float validationThreshold = 0.1f;  // Acceptable error threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;SensorReading&gt; realData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;SensorReading&gt; simulatedData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [System.Serializable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class SensorReading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public double timestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Vector3 data;  // For 3-axis sensors like IMU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float confidence;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LoadRealSensorData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void LoadRealSensorData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (realSensorData != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            string[] lines = realSensorData.text.Split(&#x27;\n&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            realData = new List&lt;SensorReading&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            foreach (string line in lines)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                string[] values = line.Split(&#x27;,&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (values.Length &gt;= 4)  // timestamp, x, y, z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SensorReading reading = new SensorReading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        timestamp = double.Parse(values[0]),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        data = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            float.Parse(values[1]),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            float.Parse(values[2]),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            float.Parse(values[3])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    realData.Add(reading);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float CalculateFidelityMetric()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (realData == null || simulatedData == null ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            realData.Count != simulatedData.Count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0.0f;  // Cannot calculate with mismatched data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float totalError = 0.0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int validComparisons = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; Mathf.Min(realData.Count, simulatedData.Count); i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float error = Vector3.Distance(realData[i].data, simulatedData[i].data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            totalError += error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            validComparisons++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (validComparisons &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float averageError = totalError / validComparisons;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Convert to fidelity score (0-1, where 1 is perfect)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Mathf.Clamp01(1.0f - (averageError / validationThreshold));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0.0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void CompareWithRealData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float fidelity = CalculateFidelityMetric();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;Sensor fidelity: {fidelity * 100:F2}%&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (fidelity &lt; 0.8f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Debug.LogWarning(&quot;Sensor simulation fidelity is below 80%. Consider adjusting noise parameters.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="best-practices-for-sensor-simulation">Best Practices for Sensor Simulation<a href="#best-practices-for-sensor-simulation" class="hash-link" aria-label="Direct link to Best Practices for Sensor Simulation" title="Direct link to Best Practices for Sensor Simulation" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="modeling-guidelines">Modeling Guidelines<a href="#modeling-guidelines" class="hash-link" aria-label="Direct link to Modeling Guidelines" title="Direct link to Modeling Guidelines" translate="no">​</a></h3>
<ol>
<li class=""><strong>Characterize Real Sensors</strong>: Measure actual sensor noise, bias, and drift parameters</li>
<li class=""><strong>Validate Against Hardware</strong>: Compare simulation output with real sensor data</li>
<li class=""><strong>Consider Environmental Factors</strong>: Include temperature, humidity, and lighting effects</li>
<li class=""><strong>Account for Sensor Placement</strong>: Model mounting position and orientation errors</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="performance-considerations">Performance Considerations<a href="#performance-considerations" class="hash-link" aria-label="Direct link to Performance Considerations" title="Direct link to Performance Considerations" translate="no">​</a></h3>
<ul>
<li class=""><strong>Efficient Raycasting</strong>: Use optimized algorithms for LiDAR simulation</li>
<li class=""><strong>Texture Compression</strong>: Balance image quality with performance for RGB-D sensors</li>
<li class=""><strong>Update Rate Management</strong>: Match simulation update rates to real sensor frequencies</li>
<li class=""><strong>Memory Management</strong>: Efficiently handle large point cloud and image data</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="integration-strategies">Integration Strategies<a href="#integration-strategies" class="hash-link" aria-label="Direct link to Integration Strategies" title="Direct link to Integration Strategies" translate="no">​</a></h3>
<ul>
<li class=""><strong>Modular Design</strong>: Create separate components for each sensor type</li>
<li class=""><strong>Calibration Support</strong>: Include parameters for sensor calibration</li>
<li class=""><strong>ROS Message Compatibility</strong>: Ensure proper message format for robotics frameworks</li>
<li class=""><strong>Data Logging</strong>: Include facilities for recording and analyzing sensor data</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="summary">Summary<a href="#summary" class="hash-link" aria-label="Direct link to Summary" title="Direct link to Summary" translate="no">​</a></h2>
<p>This chapter covered the implementation of realistic sensor simulation for digital twins in humanoid robotics. We explored LiDAR simulation with proper noise modeling, depth camera and RGB-D pipeline implementation, IMU modeling with drift characteristics, and sensor synchronization techniques. The fidelity of sensor simulation is crucial for the transferability of algorithms from simulation to reality, and proper validation against real hardware ensures that the digital twin accurately represents the physical system.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/nabila-sharif/AI---Humanoid-Robotics-Book/tree/main/frontend_book/docs/module-2/chapter-3-content.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/module-2/chapter-2-content"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Chapter 2: High-Fidelity Environments with Unity</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction-to-sensor-simulation-in-digital-twins" class="table-of-contents__link toc-highlight">Introduction to Sensor Simulation in Digital Twins</a></li><li><a href="#lidar-simulation-and-noise-characteristics" class="table-of-contents__link toc-highlight">LiDAR Simulation and Noise Characteristics</a><ul><li><a href="#lidar-physics-in-simulation" class="table-of-contents__link toc-highlight">LiDAR Physics in Simulation</a></li><li><a href="#lidar-simulation-implementation" class="table-of-contents__link toc-highlight">LiDAR Simulation Implementation</a></li><li><a href="#noise-modeling-for-lidar-sensors" class="table-of-contents__link toc-highlight">Noise Modeling for LiDAR Sensors</a></li><li><a href="#advanced-lidar-simulation-features" class="table-of-contents__link toc-highlight">Advanced LiDAR Simulation Features</a></li></ul></li><li><a href="#depth-camera-and-rgb-d-simulation" class="table-of-contents__link toc-highlight">Depth Camera and RGB-D Simulation</a><ul><li><a href="#depth-camera-fundamentals" class="table-of-contents__link toc-highlight">Depth Camera Fundamentals</a></li><li><a href="#depth-camera-implementation" class="table-of-contents__link toc-highlight">Depth Camera Implementation</a></li><li><a href="#rgb-d-sensor-pipeline" class="table-of-contents__link toc-highlight">RGB-D Sensor Pipeline</a></li></ul></li><li><a href="#imu-modeling-and-drift" class="table-of-contents__link toc-highlight">IMU Modeling and Drift</a><ul><li><a href="#imu-fundamentals-in-simulation" class="table-of-contents__link toc-highlight">IMU Fundamentals in Simulation</a></li><li><a href="#imu-simulation-implementation" class="table-of-contents__link toc-highlight">IMU Simulation Implementation</a></li></ul></li><li><a href="#sensor-synchronization-and-data-accuracy" class="table-of-contents__link toc-highlight">Sensor Synchronization and Data Accuracy</a><ul><li><a href="#time-synchronization-challenges" class="table-of-contents__link toc-highlight">Time Synchronization Challenges</a></li><li><a href="#synchronization-implementation" class="table-of-contents__link toc-highlight">Synchronization Implementation</a></li></ul></li><li><a href="#evaluating-sensor-realism-and-limitations" class="table-of-contents__link toc-highlight">Evaluating Sensor Realism and Limitations</a><ul><li><a href="#sensor-fidelity-metrics" class="table-of-contents__link toc-highlight">Sensor Fidelity Metrics</a></li><li><a href="#validation-against-real-hardware" class="table-of-contents__link toc-highlight">Validation Against Real Hardware</a></li></ul></li><li><a href="#best-practices-for-sensor-simulation" class="table-of-contents__link toc-highlight">Best Practices for Sensor Simulation</a><ul><li><a href="#modeling-guidelines" class="table-of-contents__link toc-highlight">Modeling Guidelines</a></li><li><a href="#performance-considerations" class="table-of-contents__link toc-highlight">Performance Considerations</a></li><li><a href="#integration-strategies" class="table-of-contents__link toc-highlight">Integration Strategies</a></li></ul></li><li><a href="#summary" class="table-of-contents__link toc-highlight">Summary</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/physical-ai-humanoid-robotics/">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2026 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>