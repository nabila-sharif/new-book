"use strict";(self.webpackChunkfrontend_book=self.webpackChunkfrontend_book||[]).push([[3508],{2547(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>_,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-3/chapter-3-content","title":"Chapter 3: Navigation & Path Planning (Nav2)","description":"Chapter 3: Navigation & Path Planning (Nav2)","source":"@site/docs/module-3/chapter-3-content.md","sourceDirName":"module-3","slug":"/module-3/chapter-3-content","permalink":"/docs/module-3/chapter-3-content","draft":false,"unlisted":false,"editUrl":"https://github.com/nabila-sharif/AI---Humanoid-Robotics-Book/tree/main/frontend_book/docs/module-3/chapter-3-content.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Chapter 3: Navigation & Path Planning (Nav2)"},"sidebar":"module3Sidebar","previous":{"title":"Module 3: The AI-Robot Brain (NVIDIA Isaac\u2122)","permalink":"/docs/module-3"}}');var o=a(4848),t=a(8453);const s={sidebar_position:4,title:"Chapter 3: Navigation & Path Planning (Nav2)"},r=void 0,l={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Topics",id:"key-topics",level:2},{value:"1. Nav2 Installation and Configuration for Humanoid Robots",id:"1-nav2-installation-and-configuration-for-humanoid-robots",level:3},{value:"2. Global and Local Planners for Bipedal Robots",id:"2-global-and-local-planners-for-bipedal-robots",level:3},{value:"3. Nav2 Parameter Configuration for Bipedal Constraints",id:"3-nav2-parameter-configuration-for-bipedal-constraints",level:3},{value:"4. Bipedal-Safe Navigation Scenarios",id:"4-bipedal-safe-navigation-scenarios",level:3},{value:"5. Nav2 Integration with Isaac ROS",id:"5-nav2-integration-with-isaac-ros",level:3},{value:"Practical Implementation",id:"practical-implementation",level:2},{value:"Setting up Nav2 for Humanoid Robots",id:"setting-up-nav2-for-humanoid-robots",level:3},{value:"Nav2 Configuration for Bipedal Navigation",id:"nav2-configuration-for-bipedal-navigation",level:3},{value:"Humanoid-Specific Path Planning Node",id:"humanoid-specific-path-planning-node",level:3},{value:"Bipedal Navigation Simulation",id:"bipedal-navigation-simulation",level:3},{value:"Troubleshooting Guide",id:"troubleshooting-guide",level:2},{value:"Common Installation Issues",id:"common-installation-issues",level:3},{value:"Navigation Performance Issues",id:"navigation-performance-issues",level:3},{value:"Simulation Problems",id:"simulation-problems",level:3},{value:"Hands-On Exercises",id:"hands-on-exercises",level:2},{value:"Exercise 1: Nav2 Installation and Configuration",id:"exercise-1-nav2-installation-and-configuration",level:3},{value:"Exercise 2: Bipedal Navigation Planning",id:"exercise-2-bipedal-navigation-planning",level:3},{value:"Exercise 3: Navigation Integration and Testing",id:"exercise-3-navigation-integration-and-testing",level:3},{value:"Assessment Criteria",id:"assessment-criteria",level:2}];function c(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"Chapter 3: Navigation & Path Planning (Nav2)"}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Install and configure Nav2 for humanoid robots with bipedal locomotion constraints"}),"\n",(0,o.jsx)(e.li,{children:"Implement global and local planners adapted for bipedal navigation"}),"\n",(0,o.jsx)(e.li,{children:"Configure Nav2 parameters specifically for humanoid robot dynamics"}),"\n",(0,o.jsx)(e.li,{children:"Simulate bipedal-safe navigation scenarios using Nav2"}),"\n",(0,o.jsx)(e.li,{children:"Integrate Nav2 with Isaac ROS for complete navigation solutions"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-topics",children:"Key Topics"}),"\n",(0,o.jsx)(e.h3,{id:"1-nav2-installation-and-configuration-for-humanoid-robots",children:"1. Nav2 Installation and Configuration for Humanoid Robots"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"System requirements and prerequisites for Nav2"}),"\n",(0,o.jsx)(e.li,{children:"Installing Nav2 packages with humanoid-specific dependencies"}),"\n",(0,o.jsx)(e.li,{children:"Setting up ROS 2 environment for navigation"}),"\n",(0,o.jsx)(e.li,{children:"Configuring Nav2 for bipedal locomotion constraints"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-global-and-local-planners-for-bipedal-robots",children:"2. Global and Local Planners for Bipedal Robots"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understanding global planner algorithms for humanoid navigation"}),"\n",(0,o.jsx)(e.li,{children:"Configuring local planners for bipedal-safe path execution"}),"\n",(0,o.jsx)(e.li,{children:"Custom costmap layers for humanoid-specific navigation"}),"\n",(0,o.jsx)(e.li,{children:"Humanoid-specific path optimization techniques"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-nav2-parameter-configuration-for-bipedal-constraints",children:"3. Nav2 Parameter Configuration for Bipedal Constraints"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adjusting velocity and acceleration limits for bipedal locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Configuring balance-aware navigation parameters"}),"\n",(0,o.jsx)(e.li,{children:"Setting appropriate safety margins for bipedal robots"}),"\n",(0,o.jsx)(e.li,{children:"Tuning planners for humanoid kinematic constraints"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"4-bipedal-safe-navigation-scenarios",children:"4. Bipedal-Safe Navigation Scenarios"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Creating navigation scenarios that account for bipedal stability"}),"\n",(0,o.jsx)(e.li,{children:"Implementing safe path planning around obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Handling dynamic environments with bipedal constraints"}),"\n",(0,o.jsx)(e.li,{children:"Simulating navigation in various terrain conditions"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"5-nav2-integration-with-isaac-ros",children:"5. Nav2 Integration with Isaac ROS"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Connecting Nav2 with Isaac ROS perception systems"}),"\n",(0,o.jsx)(e.li,{children:"Implementing sensor fusion for navigation"}),"\n",(0,o.jsx)(e.li,{children:"Creating complete perception-navigation pipeline"}),"\n",(0,o.jsx)(e.li,{children:"Validating integrated systems for humanoid robots"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"practical-implementation",children:"Practical Implementation"}),"\n",(0,o.jsx)(e.h3,{id:"setting-up-nav2-for-humanoid-robots",children:"Setting up Nav2 for Humanoid Robots"}),"\n",(0,o.jsx)(e.p,{children:"To configure Nav2 for humanoid robot navigation, you need to install the appropriate packages and configure the system for bipedal constraints:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"System Requirements"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"ROS 2 installation (Humble Hawksbill recommended)"}),"\n",(0,o.jsx)(e.li,{children:"Nav2 packages and dependencies"}),"\n",(0,o.jsx)(e.li,{children:"Humanoid robot model with appropriate URDF"}),"\n",(0,o.jsx)(e.li,{children:"Sensor configuration for navigation (lidar, cameras, IMU)"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Installation Process"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Install ROS 2 Humble or newer"}),"\n",(0,o.jsxs)(e.li,{children:["Install Nav2 packages: ",(0,o.jsx)(e.code,{children:"sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup"})]}),"\n",(0,o.jsx)(e.li,{children:"Install additional dependencies for humanoid navigation"}),"\n",(0,o.jsx)(e.li,{children:"Configure robot-specific parameters"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Initial Configuration"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Create navigation configuration files specific to humanoid robot"}),"\n",(0,o.jsx)(e.li,{children:"Configure costmaps for bipedal navigation"}),"\n",(0,o.jsx)(e.li,{children:"Set up transforms and coordinate frames"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"nav2-configuration-for-bipedal-navigation",children:"Nav2 Configuration for Bipedal Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Here's a complete Nav2 configuration tailored for bipedal humanoid robots:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Navigation configuration for bipedal humanoid robot\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    default_nav_through_poses_bt_xml: /opt/ros/humble/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_and_recovery.xml\n    default_nav_to_pose_bt_xml: /opt/ros/humble/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_and_recovery.xml\n    plugin_lib_names:\n      - nav2_compute_path_to_pose_action_bt_node\n      - nav2_compute_path_through_poses_action_bt_node\n      - nav2_smooth_path_action_bt_node\n      - nav2_follow_path_action_bt_node\n      - nav2_spin_action_bt_node\n      - nav2_wait_action_bt_node\n      - nav2_assisted_teleop_action_bt_node\n      - nav2_back_up_action_bt_node\n      - nav2_drive_on_heading_bt_node\n      - nav2_clear_costmap_service_bt_node\n      - nav2_is_stuck_condition_bt_node\n      - nav2_are_error_positions_close_condition_bt_node\n      - nav2_would_a_controller_recovery_help_condition_bt_node\n      - nav2_am_i_oscillating_condition_bt_node\n      - nav2_is_recovering_from_costmap_blockage_condition_bt_node\n      - nav2_is_path_valid_condition_bt_node\n      - nav2_is_goal_reached_condition_bt_node\n      - nav2_is_path_blocked_condition_bt_node\n      - nav2_is_battery_low_condition_bt_node\n      - nav2_navigate_through_poses_action_bt_node\n      - nav2_navigate_to_pose_action_bt_node\n      - nav2_remove_passed_goals_action_bt_node\n      - nav2_planner_selector_bt_node\n      - nav2_controller_selector_bt_node\n      - nav2_goal_checker_selector_bt_node\n      - nav2_recover_nav_node_bt_node\n      - nav2_pipeline_sequence_bt_node\n      - nav2_round_robin_node_bt_node\n      - nav2_transform_available_condition_bt_node\n      - nav2_time_expired_condition_bt_node\n      - nav2_path_expiring_timer_condition\n      - nav2_distance_traveled_condition_bt_node\n      - nav2_single_trigger_bt_node\n      - nav2_is_battery_charging_condition_bt_node\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 10.0  # Lower frequency for bipedal stability\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid-specific controller with bipedal constraints\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_horizon: 2.0  # Longer horizon for stability\n      frequency: 10.0\n      velocity_samples: 1\n      model_dt: 0.1  # Slower updates for stability\n      batch_size: 2000\n      vx_std: 0.1  # Reduced for bipedal stability\n      vy_std: 0.05\n      wxy_std: 0.1  # Reduced for bipedal stability\n      vx_max: 0.3  # Reduced max speed for bipedal safety\n      vx_min: -0.1\n      vy_max: 0.1\n      wz_max: 0.3  # Reduced angular velocity for balance\n      wz_min: -0.3\n      model_noise: 0.05\n      temperature: 0.3\n      horizon_delay: 1\n      control_horizon: 4\n      xy_goal_tolerance: 0.3  # Larger tolerance for bipedal robots\n      yaw_goal_tolerance: 0.3\n      stateful: true\n      motion_model: "DiffDrive"\n      reference_tracker:\n        k_phi: 1.5  # Reduced for stability\n        k_delta: 1.0  # Reduced for stability\n        k_vel: 0.8  # Reduced for stability\n        k_omega: 0.3  # Reduced for stability\n        track_error_scale: 1.0\n        cmd_vel_scale: 1.0\n        velocity_scaling_tolerance: 0.1\n        velocity_scaling_min: 0.05\n        max_velocity_scaling_factor: 1.0\n        min_velocity_scaling_factor: 0.05\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_rollout_costs: True\n      lethal_cost_threshold: 100\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05  # Higher resolution for detailed planning\n      transform_tolerance: 0.5\n      footprint: "[[-0.4, -0.3], [-0.4, 0.3], [0.4, 0.3], [0.4, -0.3]]"  # Larger for humanoid\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0  # Higher inflation for safety\n        inflation_radius: 0.55  # Larger safety margin for bipedal robots\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 8\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n'})}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-path-planning-node",children:"Humanoid-Specific Path Planning Node"}),"\n",(0,o.jsx)(e.p,{children:"Here's an example of implementing a humanoid-specific path planning node:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import Header\nimport math\n\nclass HumanoidPathPlanner(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_path_planner\')\n\n        # Create action client for navigation\n        self.nav_client = ActionClient(\n            self, NavigateToPose, \'navigate_to_pose\'\n        )\n\n        # Bipedal-specific parameters\n        self.max_step_height = 0.15  # Maximum step height for bipedal robot\n        self.min_path_width = 0.6    # Minimum path width for safe bipedal navigation\n        self.balance_margin = 0.2    # Safety margin for balance\n\n        # Navigation goal publisher\n        self.goal_publisher = self.create_publisher(\n            PoseStamped, \'/goal_pose\', 10\n        )\n\n    def create_bipedal_safe_path(self, start_pose, goal_pose):\n        """\n        Create a path that considers bipedal locomotion constraints\n        """\n        # Calculate direct path\n        dx = goal_pose.pose.position.x - start_pose.pose.position.x\n        dy = goal_pose.pose.position.y - start_pose.pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        # Calculate intermediate waypoints considering bipedal constraints\n        waypoints = []\n\n        # Add intermediate waypoints for smoother navigation\n        num_waypoints = max(5, int(distance / 0.5))  # At least 5 waypoints, 0.5m spacing\n\n        for i in range(1, num_waypoints):\n            t = i / num_waypoints\n            waypoint = PoseStamped()\n            waypoint.header = Header()\n            waypoint.header.stamp = self.get_clock().now().to_msg()\n            waypoint.header.frame_id = "map"\n\n            waypoint.pose.position.x = start_pose.pose.position.x + t * dx\n            waypoint.pose.position.y = start_pose.pose.position.y + t * dy\n            waypoint.pose.position.z = start_pose.pose.position.z  # Maintain height\n\n            # Calculate orientation toward goal\n            target_yaw = math.atan2(dy, dx)\n            waypoint.pose.orientation = self.yaw_to_quaternion(target_yaw)\n\n            waypoints.append(waypoint)\n\n        # Add final goal\n        final_waypoint = PoseStamped()\n        final_waypoint.header = Header()\n        final_waypoint.header.stamp = self.get_clock().now().to_msg()\n        final_waypoint.header.frame_id = "map"\n        final_waypoint.pose = goal_pose.pose\n        waypoints.append(final_waypoint)\n\n        return waypoints\n\n    def yaw_to_quaternion(self, yaw):\n        """\n        Convert yaw angle to quaternion\n        """\n        from geometry_msgs.msg import Quaternion\n        import math\n\n        q = Quaternion()\n        q.w = math.cos(yaw / 2.0)\n        q.x = 0.0\n        q.y = 0.0\n        q.z = math.sin(yaw / 2.0)\n        return q\n\n    def check_bipedal_navigation_feasibility(self, path):\n        """\n        Check if the path is feasible for bipedal navigation\n        """\n        if len(path) < 2:\n            return False, "Path too short"\n\n        # Check for obstacles and terrain constraints\n        for i in range(len(path) - 1):\n            current_pose = path[i].pose\n            next_pose = path[i + 1].pose\n\n            # Calculate distance between consecutive poses\n            dx = next_pose.position.x - current_pose.position.x\n            dy = next_pose.position.y - current_pose.position.y\n            step_distance = math.sqrt(dx*dx + dy*dy)\n\n            # Check if step is too large for bipedal robot\n            if step_distance > 0.5:  # Max step distance for bipedal\n                return False, f"Step too large at point {i}: {step_distance:.2f}m"\n\n        return True, "Path is feasible for bipedal navigation"\n\n    def navigate_with_bipedal_constraints(self, goal_pose):\n        """\n        Navigate to goal with bipedal-specific constraints\n        """\n        # First, check if navigation is feasible\n        path = self.create_bipedal_safe_path(self.get_current_pose(), goal_pose)\n        feasible, reason = self.check_bipedal_navigation_feasibility(path)\n\n        if not feasible:\n            self.get_logger().error(f"Navigation not feasible: {reason}")\n            return False\n\n        # Send navigation goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose = goal_pose\n\n        self.get_logger().info("Sending navigation goal with bipedal constraints...")\n\n        # Wait for action server\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error("Navigation action server not available")\n            return False\n\n        # Send goal\n        future = self.nav_client.send_goal_async(goal_msg)\n        return future\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    planner = HumanoidPathPlanner()\n\n    # Example: Navigate to a specific pose\n    goal_pose = PoseStamped()\n    goal_pose.header.frame_id = "map"\n    goal_pose.pose.position.x = 5.0\n    goal_pose.pose.position.y = 3.0\n    goal_pose.pose.position.z = 0.0\n    goal_pose.pose.orientation.w = 1.0  # No rotation\n\n    future = planner.navigate_with_bipedal_constraints(goal_pose)\n\n    if future:\n        rclpy.spin_until_future_complete(planner, future)\n\n    planner.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"bipedal-navigation-simulation",children:"Bipedal Navigation Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Here's an example of simulating bipedal-safe navigation scenarios:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Odometry\nimport numpy as np\nimport math\n\nclass BipedalNavigationSimulator(Node):\n    def __init__(self):\n        super().__init__(\'bipedal_navigation_simulator\')\n\n        # Robot state variables\n        self.current_x = 0.0\n        self.current_y = 0.0\n        self.current_yaw = 0.0\n        self.linear_vel = 0.0\n        self.angular_vel = 0.0\n\n        # Bipedal-specific parameters\n        self.max_linear_vel = 0.3  # m/s for bipedal safety\n        self.max_angular_vel = 0.3  # rad/s for balance\n        self.bipedal_step_size = 0.2  # Max step size for bipedal\n        self.balance_threshold = 0.1  # Balance maintenance threshold\n\n        # Publishers and subscribers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.odom_pub = self.create_publisher(Odometry, \'/odom\', 10)\n        self.scan_pub = self.create_publisher(LaserScan, \'/scan\', 10)\n\n        # Timer for simulation updates\n        self.timer = self.create_timer(0.1, self.update_simulation)  # 10 Hz\n\n        self.get_logger().info("Bipedal Navigation Simulator initialized")\n\n    def update_simulation(self):\n        """\n        Update the simulation state based on current commands\n        """\n        # Update robot position based on current velocities\n        dt = 0.1  # Time step\n\n        # Update position with forward kinematics\n        self.current_x += self.linear_vel * math.cos(self.current_yaw) * dt\n        self.current_y += self.linear_vel * math.sin(self.current_yaw) * dt\n        self.current_yaw += self.angular_vel * dt\n\n        # Normalize yaw to [-pi, pi]\n        while self.current_yaw > math.pi:\n            self.current_yaw -= 2 * math.pi\n        while self.current_yaw < -math.pi:\n            self.current_yaw += 2 * math.pi\n\n        # Publish odometry\n        odom_msg = Odometry()\n        odom_msg.header.stamp = self.get_clock().now().to_msg()\n        odom_msg.header.frame_id = \'odom\'\n        odom_msg.child_frame_id = \'base_link\'\n\n        odom_msg.pose.pose.position.x = self.current_x\n        odom_msg.pose.pose.position.y = self.current_y\n        odom_msg.pose.pose.position.z = 0.0\n\n        # Convert yaw to quaternion\n        from geometry_msgs.msg import Quaternion\n        q = self.yaw_to_quaternion(self.current_yaw)\n        odom_msg.pose.pose.orientation = q\n\n        # Set velocities\n        odom_msg.twist.twist.linear.x = self.linear_vel\n        odom_msg.twist.twist.angular.z = self.angular_vel\n\n        self.odom_pub.publish(odom_msg)\n\n        # Publish simulated laser scan\n        self.publish_simulated_scan()\n\n    def yaw_to_quaternion(self, yaw):\n        """\n        Convert yaw angle to quaternion\n        """\n        from geometry_msgs.msg import Quaternion\n        q = Quaternion()\n        q.w = math.cos(yaw / 2.0)\n        q.x = 0.0\n        q.y = 0.0\n        q.z = math.sin(yaw / 2.0)\n        return q\n\n    def publish_simulated_scan(self):\n        """\n        Publish simulated laser scan data\n        """\n        scan_msg = LaserScan()\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\n        scan_msg.header.frame_id = \'laser_frame\'\n\n        # Laser scan parameters\n        scan_msg.angle_min = -math.pi / 2  # -90 degrees\n        scan_msg.angle_max = math.pi / 2   # 90 degrees\n        scan_msg.angle_increment = math.pi / 180  # 1 degree increments\n        scan_msg.time_increment = 0.0\n        scan_msg.scan_time = 0.1\n        scan_msg.range_min = 0.1\n        scan_msg.range_max = 10.0\n\n        # Generate simulated ranges (with some obstacles)\n        num_readings = int((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment) + 1\n        ranges = []\n\n        for i in range(num_readings):\n            angle = scan_msg.angle_min + i * scan_msg.angle_increment\n\n            # Simulate some obstacles in the environment\n            distance = scan_msg.range_max  # Default to max range\n\n            # Add some simulated obstacles\n            if abs(angle) < 0.2:  # Front of robot\n                if 2.0 < self.current_x < 4.0 and abs(self.current_y - 1.0) < 0.5:\n                    distance = 1.5  # Obstacle ahead\n\n            ranges.append(distance)\n\n        scan_msg.ranges = ranges\n        scan_msg.intensities = [1.0] * len(ranges)\n\n        self.scan_pub.publish(scan_msg)\n\n    def set_navigation_command(self, linear, angular):\n        """\n        Set navigation command with bipedal constraints\n        """\n        # Apply bipedal-specific limits\n        self.linear_vel = max(-self.max_linear_vel, min(linear, self.max_linear_vel))\n        self.angular_vel = max(-self.max_angular_vel, min(angular, self.max_angular_vel))\n\n        # Create and publish command\n        cmd_msg = Twist()\n        cmd_msg.linear.x = self.linear_vel\n        cmd_msg.angular.z = self.angular_vel\n\n        self.cmd_vel_pub.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    simulator = BipedalNavigationSimulator()\n\n    # Example: Move forward slowly (bipedal-safe speed)\n    simulator.set_navigation_command(0.1, 0.0)  # 0.1 m/s forward\n\n    print("Starting bipedal navigation simulation...")\n    print("The robot will move forward at a safe speed for bipedal locomotion.")\n\n    try:\n        rclpy.spin(simulator)\n    except KeyboardInterrupt:\n        print("Simulation stopped by user")\n    finally:\n        simulator.set_navigation_command(0.0, 0.0)  # Stop the robot\n        simulator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-guide",children:"Troubleshooting Guide"}),"\n",(0,o.jsx)(e.h3,{id:"common-installation-issues",children:"Common Installation Issues"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ROS 2 Version Compatibility"}),": Ensure Nav2 packages match your ROS 2 distribution"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dependency Conflicts"}),": Resolve package dependencies with apt"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Navigation Configuration"}),": Verify all required configuration files are present"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"navigation-performance-issues",children:"Navigation Performance Issues"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Planning Failures"}),": Check costmap configuration and obstacle detection"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bipedal Instability"}),": Reduce navigation speeds and adjust controller parameters"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Goal Not Reached"}),": Increase tolerances and verify transform frames"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"simulation-problems",children:"Simulation Problems"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"TF Issues"}),": Ensure all coordinate frames are properly published"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensor Data"}),": Verify sensor topics are correctly configured"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Control Frequency"}),": Adjust controller frequency for stability"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-exercises",children:"Hands-On Exercises"}),"\n",(0,o.jsx)(e.h3,{id:"exercise-1-nav2-installation-and-configuration",children:"Exercise 1: Nav2 Installation and Configuration"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Install Nav2 packages for humanoid robot navigation"}),"\n",(0,o.jsx)(e.li,{children:"Configure Nav2 parameters for bipedal locomotion constraints"}),"\n",(0,o.jsx)(e.li,{children:"Set up costmaps and planners for humanoid-specific navigation"}),"\n",(0,o.jsx)(e.li,{children:"Verify the configuration with a simple navigation test"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-2-bipedal-navigation-planning",children:"Exercise 2: Bipedal Navigation Planning"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Configure global and local planners for bipedal robots"}),"\n",(0,o.jsx)(e.li,{children:"Set appropriate velocity and acceleration limits for bipedal locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Test path planning in various simulated environments"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate the safety margins and balance constraints"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-3-navigation-integration-and-testing",children:"Exercise 3: Navigation Integration and Testing"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Integrate Nav2 with Isaac ROS perception systems"}),"\n",(0,o.jsx)(e.li,{children:"Create a complete perception-navigation pipeline"}),"\n",(0,o.jsx)(e.li,{children:"Test the integrated system in simulation"}),"\n",(0,o.jsx)(e.li,{children:"Validate the navigation performance and safety"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"assessment-criteria",children:"Assessment Criteria"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Students can configure Nav2 for bipedal humanoid robot navigation"}),"\n",(0,o.jsx)(e.li,{children:"Students can implement global and local planners with humanoid constraints"}),"\n",(0,o.jsx)(e.li,{children:"Students can simulate safe navigation scenarios for bipedal robots"}),"\n",(0,o.jsx)(e.li,{children:"Students can integrate Nav2 with Isaac ROS for complete solutions"}),"\n"]})]})}function _(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453(n,e,a){a.d(e,{R:()=>s,x:()=>r});var i=a(6540);const o={},t=i.createContext(o);function s(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);